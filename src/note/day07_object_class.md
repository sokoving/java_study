# 절차지향 프로그래밍(Procedure Oriented Programming)
 - 처음부터 순차적으로 코드를 읽어 프로그래을 실행한다
 - 장점: 빠르다
 - 단점
    + 한 부분을 고치려면 전체를 고쳐야 한다.(유지보수 문제)
    + 특정 코드만 개별적으로 실행 불가
    + 무조건 코딩한 순서대로 실행
 - COBOL, FORTRAN, C 같은 고레벨 언어
 
# 객체지향 프로그래밍 (OOP : Object Oriented Programming)
 - 코드를 개별적으로 실행, 수정 가능
 - 대규모 프로그램에 적합
 - 예시) 나: 지갑에 돈을 요구한다(5천 원) / 지갑: 돈이 있는지 확인하고 있으면 준다.
 - JAVA, C++, RUBY

# 객체
 - 설계용 클래스를 기반으로 해 생겨난 실체 : *instance*
 - 객체(데이터)들은 서로 독립적이지만 서로 상호작용을 해 프로그램을 구현한다.
 - *필드*라는 정보를 가지고 있으며 객체마다 쓸 수 수 있는 *메서드*가 다르다.

# 클래스
 - 객체를 만들기 위한 설계도
 - 클래스를 기반으로 객체를 해당 클래스의 *인스턴스, instance*라고 부른다 
 - 하나의 클래스로 여러 인스턴스를 만들 수 있다

## 클래스의 종류
 - 설계용 클래스 : *필드*, *생성자*, *메서드*를 적는다
 - 실행용 클래스 : 생성자를 호출해 인스턴스를 만든다

## 클래스의 구성
``` 
package day08.syrup;   > package [클래스 파일 경로]

im

public class Apple{
}
```


   + 파일명과 대소문자까지 똑같이, 파스칼 케이스로.
 > public class Pen{}

## 속성(field)
   + 객체가 가진 정보
   + 변수랑 비슷하게 생김 (타입과 이름은 적는다)
   + 초기화는 객체를 만들 때 한다(설계 클래스에서 X)
   + js에서 프로퍼티의 키와 매치됨
> String name;
### 필드의 종류(ex 자동차)
   + 고유 데이터: 값이 잘 바뀌지 않는 데이터 (ex 제작회사, 모델명, 색상, 최고속도)
   + 상태 데이터: 값이 수시로 바뀌로 데이터 (ex 현재 속도, 엔진 회전 수, 현재 연료량)
   + 부품 데이터: 객체를 이루는 (ex 엔진, 타이어, 핸들 에어컨)
### 필드의 선언 위치
   + 클래스 블록 안
   + 메서드, 생성자 블록에서는 불가능
   - 메서드, 생성자 블록에서 생성된 건 지역 변수(필드X)

## 생성자(constructor)
   + 생성자를 호출해서 인스턴스를 만들고 필드를 초기화한다.
   + new 연산자와 같이 사용됨
   + 함수랑 비슷하게 생겼는데 class랑 이름이 똑같음
   - 기능(method)
      + 객체가 할 수 있는 일
      + 함수랑 비슷하게 생김
# 생성자의 이름
클래스 이름과 대소문자까지 동일하게
# 기본 생성자
파라미터가 없는 생성자
설계도에서 하나도 안 만들었으면 기본으로 생성된다
생성자를 하나 이상 선언하면 *생성되지 않는다.*
# 생성자는 사실 보이드 함수 return을 탈출문으로 쓸 수 있다 


# 객체의 타입(참조 타입)
 - 기본 타입
    + 미리 준비되어 있는 타입
    + int, boolean, String 등등
 - 참조 타입
   + 사용자 정의 타입


# 패키지
+ 패키지로 클래스를 체계적으로 관리한다.
  - 패키지 경로를 늘리면 클래스를 식별하기 편하다(?)
+ 클래스가 이름이라면 패키지는 성
  - 같은 User 클래스라도 app.myuser.User와 app.benuser.User는 다른 클래스
  - 동일 패키지에는 중복되는 이름의 클래스 생성할 수 없다.

